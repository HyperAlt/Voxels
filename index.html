<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloxd.io Clone</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.165.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <script>
        // main.js content starts here (embedded)

        let scene, camera, renderer, controls;
        const world = {}; // To store our block data
        const blockSize = 1; // Size of each block

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            grass_top: textureLoader.load('textures/grass_top.png'),
            dirt: textureLoader.load('textures/dirt.png'),
            stone: textureLoader.load('textures/stone.png'),
            sand: textureLoader.load('textures/sand.png'),
            iron_ore: textureLoader.load('textures/iron_ore.png'),
        };

        // Function to create a material for a block type
        function createBlockMaterial(textureName) {
            // For this basic setup, we use the same texture for all faces.
            // For grass, you'd typically have different textures for top, side, and bottom.
            // A more advanced approach would use a texture atlas and UV mapping.
            return new THREE.MeshLambertMaterial({ map: textures[textureName] }); // Using LambertMaterial for basic lighting
        }

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Skybox setup
            const skyboxLoader = new THREE.CubeTextureLoader();
            const skyboxTextures = [
                'textures/px.png', 'textures/nx.png', // Right, Left
                'textures/py.png', 'textures/ny.png', // Top, Bottom
                'textures/pz.png', 'textures/nz.png'  // Front, Back
            ];
            const skybox = skyboxLoader.load(skyboxTextures);
            scene.background = skybox;

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 100); // Initial camera position

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls for camera movement
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // For smoother movement
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 500;
            controls.maxPolarAngle = Math.PI / 2; // Prevent camera from going below ground

            // Basic lighting (essential for MeshLambertMaterial)
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            // Generate the terrain
            generateTerrain(100, 100, 15); // Generate a 100x100 terrain with a height scale of 15

            // Start the game loop
            animate();
        }

        // Function to handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Function to add a single block to the scene
        function addBlock(x, y, z, type) {
            const material = createBlockMaterial(type);
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x * blockSize, y * blockSize, z * blockSize);
            scene.add(cube);
            world[`${x},${y},${z}`] = type; // Store block type in our world data structure
        }

        // Simple Perlin-like noise function for height (for demonstration, not a true Perlin implementation)
        function getNoiseHeight(x, z, scale, amplitude) {
            // This is a very basic procedural noise. For proper Perlin noise, use a library.
            const val1 = Math.sin(x * scale) * amplitude;
            const val2 = Math.cos(z * scale) * amplitude;
            const val3 = Math.sin((x + z) * scale * 0.7) * amplitude * 0.5;
            return val1 + val2 + val3;
        }

        // Function to generate the random terrain
        function generateTerrain(width, depth, heightScale) {
            console.log("Generating terrain...");
            for (let x = -width / 2; x < width / 2; x++) {
                for (let z = -depth / 2; z < depth / 2; z++) {
                    // Calculate height using a simple noise function
                    const baseHeight = Math.floor(getNoiseHeight(x, z, 0.05, heightScale) + heightScale); // Ensures non-negative height

                    // Fill ground layers
                    for (let y = 0; y < baseHeight; y++) {
                        let blockType = 'dirt';
                        if (y < baseHeight * 0.4 && Math.random() < 0.1) { // Deeper, small chance of stone/iron_ore
                            blockType = Math.random() < 0.2 ? 'iron_ore' : 'stone';
                        }
                        addBlock(x, y, z, blockType);
                    }

                    // Add grass layer on top of the highest block
                    if (baseHeight >= 0) { // Ensure there's a block to put grass on
                        addBlock(x, baseHeight, z, 'grass_top');
                    }

                    // Add some sand around "sea level" (adjust as needed)
                    if (baseHeight < heightScale * 0.5 && baseHeight > heightScale * 0.2 && Math.random() < 0.5) {
                         addBlock(x, baseHeight, z, 'sand'); // Replace grass or top dirt with sand
                         // You might need to remove previous block if you're replacing.
                         // For simplicity, this just adds on top or replaces the last added.
                    }
                }
            }
            console.log("Terrain generation complete.");
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update controls in each frame
            renderer.render(scene, camera);
        }

        // Initialize the scene when the script loads
        init();

        // main.js content ends here
    </script>
</body>
</html>
